{"version":3,"file":"vue.js","sources":["../../src/observer/array.js","../../src/util.js","../../src/observer/index.js","../../src/state.js","../../src/compiler/index.js","../../src/init.js","../../src/index.js"],"sourcesContent":["// 拿到数组原型上的方法（旧方法）\nlet oldArrayProtoMethods = Array.prototype;\n\n// 继承一下： arrayMethods.__proto__ = oldArrayProtoMethods\nexport let arrayMethods = Object.create(oldArrayProtoMethods)\n\n// 重写 这7个 能改变原数组的方法，如果其余的数组方法，就沿着原型链找到老的数组方法\nlet methods = [\n  'push',\n  'pop',\n  'shift',\n  'shift',\n  'reverse',\n  'splice'\n]\n\nmethods.forEach(method => {\n  // 重写数组方法之后， 先走自己的函数逻辑\n  arrayMethods[method] = function (...args) {  // todo this就是observer函数里的value\n  // 再走原来函数的逻辑\n    const result = oldArrayProtoMethods[method].apply(this, args);\n    \n    let ob = this.__ob__; // __ob__ 属性是当前Oberserve的实例，作用检测是否被观测过\n    let inserted;\n\n    switch (method) {\n      case 'push': // arr.push({a:1}, {b:2})\n      case 'unshift': // 这两个方法都是追加元素 追加的内容可能是对象类型，应该被再次劫持\n        inserted = args;\n        break;\n      case 'splice': // vue.$set\n        inserted = args.splice(2) // arr.splice(0, 1, {a:1}) 索引 删除的的个数， 新增的元素\n      default:\n        break;\n    }\n \n    if(inserted) {\n      // 对数组内新增的元素 再次观测\n      ob.observeArray(inserted);\n    }\n    return result;\n  }\n})","export function proxy(vm, data, key) {\n  Object.defineProperty(vm, key, {\n    get() {\n      return vm[data][key]; // vm._data.a\n    },\n    set(newValue) { // vm.a = 100;\n      vm[data][key] = newValue; // vm._data.a = 100\n    }\n  })\n};\n\n/**\n * \n * @param {*} target 目标对象\n * @param {*} key 对象上的属性\n * @param {*} value 对象上的属性值\n */\nexport function defineProperty(target, key, value) {\n  Object.defineProperty(target, key, {\n    enumerable: false, // 不能被枚举，不能被this.walk()循环\n    configurable: false,\n    value: this\n  })\n}","import { arrayMethods } from './array';\nimport { defineProperty } from '../util';\n/**\n *  封装一个对属性观测的类\n */\nclass Observer{\n  constructor(value){\n    // todo 判断一个对象是否被观测过，看他有没有 __ob__这个属性\n    // 以下方法 代替 value.__ob__ = this 因为都是对象 ，会被重复递归 死循环\n    defineProperty(value, '__ob__', this);\n    \n\n    // 使用 defineProperty 重新定义属性\n    if (Array.isArray(value)){\n      // push shift unshift splice sort reverse pop\n      // todo 函数劫持 切片编程 （在原有的逻辑里面增加一些额外的逻辑）\n      value.__proto__ = arrayMethods;\n      // todo 观测数组中的对象类型，对象变化  {arr:[{a:1}]}\n      // 对数组中的每一项进行观测\n      this.observeArray(value);\n    } else {\n      this.walk(value)\n    }\n  }\n\n  // 对数组中的每一项进行观测\n  observeArray(value) { \n    value.forEach(item => {\n      // 观测数组中的对象类型\n      observe(item)\n    })\n  }\n  // 对value对象中每一步 都重新定义\n  // todo data是 对象情况时\n  walk(data) {\n    let keys = Object.keys(data); // 获取对象的Key\n    keys.forEach(Key => {\n      defineReactive(data, Key, data[Key]);\n    })\n  }\n}\n\nfunction defineReactive(data, Key, value) {\n  // 如果值时对象类型的话 {a:{a:1}} 需要递归观察\n  observe(value);\n  Object.defineProperty(data, Key, {\n    get() {\n      console.log('用户获取值了')\n      return value \n    },\n    set(newValue) {\n      console.log('用户设置值了')\n      if(newValue == value) return;\n      // todo 重新设置值得时候 是对象形式的话 再次观察\n      observe(newValue); // vm._data.a = {b:1}\n      value = newValue;\n    }\n  })\n}\n\n/**\n * todo 观测数据\n * @param {*} data 要检测的data 对象\n */\nexport function observe(data) {\n\n  // data 需要是对象，并且不是null\n  if(typeof data !== 'object' || data == null) {\n    return;\n  }\n  if(data.__ob__) {\n    // 已经观测过了，防止数组重复被观测\n    return data;\n  }\n  return new Observer(data)\n\n}","import { observe } from \"./observer/index\";\nimport { proxy } from \"./util\";\n\n//todo 初始化属性 状态 数据 等等\nexport function initState(vm) {  // vm.$options\n  const opts = vm.$options; // {el: \"#app\", data: ƒ}\n\n  if(opts.props) {\n    initProps();\n  }\n\n  if(opts.methods) {\n    initMethods();\n  }\n  if(opts.data) {\n    initData(vm);\n  }\n  if(opts.computed) {\n    initComputed();\n  }\n  if(opts.watch) {\n    initWatch();\n  }\n}\n\nfunction initProps() {}\nfunction initMethods() {}\n\n/**\n * 用vm.a 来代理 vm._data.a\n * @param {*} vm \n * @param {*} data \n * @param {*} key \n */\n\nfunction initData(vm) {\n  // 数据的初始化操作\n  let data = vm.$options.data; // data : function\n  // todo vm._data 是为了将data函数执行返回的结果 与vm 关联起来，否则将拿不到 data()函数的返回对象\n  vm._data = data = typeof data == 'function' ? data.call(vm) : data;\n\n  // 当我去vm上取属性时，帮我将属性的取值代理到 vm._data上\n  for(let key in data) {\n    proxy(vm, '_data', key);\n  }\n\n  // todo 数据的劫持方案 （Object.definePrototype）\n  observe(data) // 此时的data是函数执行后的结果\n}\nfunction initComputed() {}\nfunction initWatch() {} ","/*\n  <div id=\"app\">\n    <div>hello {{school.name}} <span>world</span></div>\n  </div>\n*/\n\nconst ncname = `[a-zA-Z_][\\\\-\\\\.0-9_a-zA-Z]*`; // 标签名\n// ?:匹配不捕获\nconst qnameCapture = `((?:${ncname}\\\\:)?${ncname})`; // </my:xx>\nconst startTagOpen = new RegExp(`^<${qnameCapture}`); // 标签开头的正则 捕获的内容是标签名\nconst endTag = new RegExp(`^<\\\\/${qnameCapture}[^>]*>`); // 匹配标签结尾的 </div>\nconst attribute = /^\\s*([^\\s\"'<>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/; // 匹配属性的    aaa=\"aaa\"  a='aaa'   a=aaa\nconst startTagClose = /^\\s*(\\/?)>/; // 匹配标签结束的 >    >   <div></div>  <br/>\nconst defaultTagRE = /\\{\\{((?:.|\\r?\\n)+?)\\}\\}/g;\n\nfunction start(tagName, attrs) {\n  console.log(tagName, attrs)  // 解析出 开始标签和属性\n}\n\nfunction end(tagName) {\n\n}\n\nfunction chars(text) {\n\n}\n\nfunction parseHTML(html) {\n  while(html) { // 只要html不为空，就一直解析\n    let textEnd = html.indexOf('<');\n    if(textEnd == 0) {\n      // 肯定是标签\n      const startTagMath = parseStartTag();  // 开始标签匹配的结果\n      if(startTagMath) {\n        start(startTagMath.tagName, startTagMath.attrs);\n      }\n      break;\n    }\n  }\n  \n  /**\n   * 切割元素标签中的字符串，方便后续解析\n   * @param {*} n 第几个字符\n   */\n  function advance(n) { // 将字符串进行截取操作 再更新html内容\n    html = html.substring(n)\n\n  }\n  function parseStartTag() {\n    const start = html.match(startTagOpen);\n    if(start) {\n       const match = {\n         tagName: start[1],\n         attrs: []\n       }\n      //  console.log(start) // [\"<div\", \"div\", index: 0, input: \"<div id=\"app\">↵    <div id=\"“my”\">hello {{school.name}} <span>world</span></div>↵  </div>\", groups: undefined]\n      //  console.log(match) // {tagName: \"div\", attrs: Array(0)}\n      advance(start[0].length); // 删除开始标签\n      // console.log(html) //  id=\"app\"> .. \n      // 处理属性 （如果是闭合标签 说明没有属性） \n      let end, attr;\n      // 不是结尾标签 能匹配到属性\n      while(!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {\n        match.attrs.push({ name: attr[1], value: attr[3] || attr[4] || attr[5] })\n        advance(attr[0].length); // 去掉当前属性\n      }\n      if(end) { // >\n        advance(end[0]);  // 去掉 >\n        return match;\n      }\n    }\n  }\n}\n\n/**\n * todo html模板 => render 函数\n * @param {*} template \n */\nexport function compileToFunctions(template) {\n  // 1、需要将html代码转换成 ast语法树 (可以用ast树来描述语言本身)\n\n  let ast = parseHTML(template)\n\n  // 2、通过这棵树 重新的生成代码\n  \n}\n\n/* \n  ast语法树 是用来描述代码的，可以描述 css html js  (根据语法生成的固定逻辑)\n  虚拟dom 用来描述dom结构的\n*/","//todo 进行初始化操作\nimport { initState } from './state';\nimport { compileToFunctions } from './compiler/index'\n\nexport function initMixin(Vue) {\n  Vue.prototype._init = function(options) {\n    // 定义一个 Vue的实例对象 vm\n    const vm = this;\n    vm.$options = options; // {el: \"#app\", data: ƒ}\n\n    // 初始化状态 (数据劫持，改变数据时，更新视图)\n    initState(vm);\n    \n    // todo vue核心 响应式数据原理\n\n    // 如果当前有el属性说明要渲染模板\n    if(vm.$options.el) {\n      vm.$mount(vm.$options.el)\n    }\n\n  }\n  /** 渲染模板，挂载操作\n   * el dom元素\n   */\n  Vue.prototype.$mount = function (el) {\n    // 挂载操作\n    const vm = this;\n    const options = vm.$options;\n    console.log(options)\n    // 先找到外层元素\n    el = document.querySelector(el);\n    // 渲染的顺序 render > template > dom结构\n    if (!options.render){\n      // 没render 将template转换成render方法\n      let template = options.template;\n      if(!template && el) {\n        template = el.outerHTML; // 外部模板\n      }\n      // todo 编译原理 将模板编译成render函数\n      const render = compileToFunctions(template);\n      options.render = render;\n    } \n    console.log(options.render) // 渲染时用的都是这个render\n    // 有render 方法\n    \n  }\n} \n\n// 面试：vue是mvvm框架么\n// vue只是借鉴MVVM原理，因为vue可以使用$ref直接操作dom元素","// todo 该文件给构造函数的原型上扩展方法\nimport { initMixin } from './init';\n\n/**\n * 构造函数\n * @param {*} options {el: \"#app\", data: ƒ}\n */\nfunction Vue(options) {\n  this._init(options);\n}\n\ninitMixin(Vue);\n\n// 初始化方法\n\n\nexport default Vue;"],"names":["oldArrayProtoMethods","Array","prototype","arrayMethods","Object","create","methods","forEach","method","args","result","apply","ob","__ob__","inserted","splice","observeArray","proxy","vm","data","key","defineProperty","get","set","newValue","target","value","enumerable","configurable","Observer","isArray","__proto__","walk","item","observe","keys","Key","defineReactive","console","log","initState","opts","$options","props","initData","computed","watch","_data","call","ncname","qnameCapture","startTagOpen","RegExp","attribute","startTagClose","start","tagName","attrs","parseHTML","html","textEnd","indexOf","startTagMath","parseStartTag","advance","n","substring","match","length","end","attr","push","name","compileToFunctions","template","ast","initMixin","Vue","_init","options","el","$mount","document","querySelector","render","outerHTML"],"mappings":"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"}